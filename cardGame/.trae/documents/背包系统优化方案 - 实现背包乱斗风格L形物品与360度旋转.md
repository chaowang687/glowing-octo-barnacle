## 1. 当前系统分析

**核心组件**：
- `InventoryGrid`：网格管理，处理物品放置、移除和碰撞检测
- `ItemData`：物品数据，包含宽高、图标等基本属性
- `ItemInstance`：物品实例，包含位置和旋转状态
- `ItemUI`：物品UI，处理拖拽和交互

**当前局限性**：
- 物品形状只能是矩形
- 旋转仅支持90度切换（宽高交换）
- 无法实现L形等非矩形形状

## 2. 优化目标

实现背包乱斗风格的L形物品：
- 支持3个格子组成的L形物品
- 支持360度旋转（4种朝向）
- 精确的碰撞检测
- 流畅的旋转交互

## 3. 核心改进方案

### 3.1 数据结构扩展

**修改 `ItemData`**：
- 保持现有宽高属性（L形物品设置为2x2，但实际只占用3个格子）
- 添加 `bool[2,2] shape` 数组定义L形基础形状（例如：
  ```
  [ [true, true],
    [true, false] ]
  ```
  ）

**修改 `ItemInstance`**：
- 替换 `isRotated` 为 `rotation` 字段（0, 90, 180, 270度）
- 新增 `GetActualShape()` 方法计算旋转后的实际形状

### 3.2 网格系统优化

**修改 `InventoryGrid`**：
- 重写 `CanPlace()` 方法，支持L形碰撞检测
- 重写 `PlaceItem()` 方法，基于实际形状占用格子
- 重写 `RemoveItem()` 方法，基于实际形状释放格子
- 重写 `ShowPlacementPreview()` 方法，显示旋转后的L形预览

### 3.3 旋转逻辑实现

**实现360度旋转**：
- 添加 `RotateItem()` 方法，支持顺时针旋转
- 实现 `RotateShape()` 算法，处理L形的4种朝向
- 支持旋转预览，实时显示旋转后的L形

## 4. 实现步骤

1. **扩展数据结构**：
   - 修改 `ItemData.cs`，添加 `shape` 数组支持
   - 修改 `ItemInstance.cs`，添加 `rotation` 字段

2. **实现形状旋转**：
   - 实现 `RotateShape()` 方法，支持4种旋转角度
   - 实现 `GetActualShape()` 方法，计算实际占用格子

3. **重写网格逻辑**：
   - 重写 `CanPlace()` 方法，基于实际形状检测
   - 重写 `PlaceItem()` 和 `RemoveItem()` 方法
   - 优化 `ShowPlacementPreview()` 方法

4. **UI交互优化**：
   - 修改 `ItemUI.cs`，添加旋转交互
   - 改进放置预览效果

## 5. 关键算法

### 5.1 L形旋转算法

```csharp
// 旋转2x2形状数组
private bool[,] RotateShape(bool[,] original, int rotation) {
    bool[,] rotated = new bool[2, 2];
    
    switch (rotation) {
        case 0: // 0度
            rotated = (bool[,])original.Clone();
            break;
        case 90: // 90度顺时针
            rotated[0, 0] = original[1, 0];
            rotated[0, 1] = original[0, 0];
            rotated[1, 0] = original[1, 1];
            rotated[1, 1] = original[0, 1];
            break;
        case 180: // 180度
            rotated[0, 0] = original[1, 1];
            rotated[0, 1] = original[1, 0];
            rotated[1, 0] = original[0, 1];
            rotated[1, 1] = original[0, 0];
            break;
        case 270: // 270度顺时针
            rotated[0, 0] = original[0, 1];
            rotated[0, 1] = original[1, 1];
            rotated[1, 0] = original[0, 0];
            rotated[1, 1] = original[1, 0];
            break;
    }
    
    return rotated;
}
```

### 5.2 L形碰撞检测

```csharp
// 检查L形物品是否可以放置
public bool CanPlace(ItemInstance item, int x, int y) {
    // 检查边界
    if (x < 0 || y < 0 || x + 2 > width || y + 2 > height) {
        return false;
    }
    
    // 获取旋转后的实际形状
    bool[,] shape = item.GetActualShape();
    
    // 检查每个占用格子
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            if (shape[i, j]) {
                int gridX = x + i;
                int gridY = y + j;
                if (gridSlots[gridX, gridY] != null) {
                    return false;
                }
            }
        }
    }
    
    return true;
}
```

## 6. 兼容性考虑

- 保持现有矩形物品的兼容性
- 现有存档数据可以正常加载
- 新的L形物品作为扩展功能添加

## 7. 预期效果

- 实现3个格子组成的L形物品
- 支持0、90、180、270度四种旋转
- 精确的碰撞检测
- 流畅的旋转交互
- 与现有系统无缝集成